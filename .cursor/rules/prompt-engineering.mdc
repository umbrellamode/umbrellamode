---
description: "Project-wide Cursor rules: task-driven, small diffs, tests & validation. Adapted from a prompt-engineering cheat sheet."
alwaysApply: true
---

# Cursor Project Rules (Base)

Authoritative behavior and prompt patterns for Cursor across this repo. These rules are adapted from a compact prompt‑engineering playbook and tuned for code‑heavy workflows.

---

## 0) Prime Directives
- **Be task‑driven**: restate the user’s goal, constraints, and acceptance criteria before writing code.
- **Prefer small, safe changes**: propose a minimal plan, then produce focused diffs.
- **Stay consistent with the repo**: follow existing conventions (language, style, framework, lint/format, folder layout).
- **Be explicit**: show assumptions, list edge cases, and call out risks.
- **Verify**: include a quick checklist to validate the change (tests, type checks, build, local run steps).

---

## 1) Default Response Format
Always structure answers as:

1. **Summary** – one‑sentence goal recap.
2. **Plan** – numbered, minimal steps (1–5 items).
3. **Change set** – use concise diffs or code blocks per file with paths.
4. **Validation** – how to run, test, and verify.
5. **Notes** – trade‑offs, assumptions, and follow‑ups.

> If scope is ambiguous, include a **“Questions”** block with the fewest decisive clarifiers, then still provide a best‑effort proposal with safe defaults.

---

## 2) Output Discipline
- **File‑scoped diffs only**. For each file show: path → snippet/diff → explanation when needed.
- **No placeholder secrets**; use env var names and `.env.example` updates.
- **Deterministic formats**: Use XML tags for structured data (more token-efficient than JSON). YAML or tables must be valid and parseable.
- **XML tag efficiency**: Prefer `<tag>content</tag>` over JSON for structured data. Use semantic tag names like `<user>`, `<config>`, `<error>`.
- **Cite interfaces**: when using an external API or lib, show the exact function signatures you rely on.
- **Comment lightly**: focus comments on non‑obvious design decisions or tricky logic.

---

## 2.1) XML Tag Best Practices
- **Semantic naming**: Use descriptive tag names that convey meaning (`<user>`, `<config>`, `<error>`, `<result>`)
- **Consistent structure**: Maintain consistent tag hierarchy and naming conventions
- **Minimal nesting**: Avoid deep nesting; prefer flat structures when possible
- **Self-closing tags**: Use `<tag/>` for empty elements to save tokens
- **Examples**:
  ```xml
  <user>
    <id>123</id>
    <name>John Doe</name>
    <email>john@example.com</email>
  </user>
  
  <config>
    <debug>true</debug>
    <timeout>30</timeout>
  </config>
  ```

---

## 3) Planning Patterns (Prompt Techniques)
Use these lightweight prompt patterns when helpful:

- **CRISP Goal**: *Constraint, Result, Inputs, Steps, Proof*.
- **Few‑shot**: show 1–2 short, correct examples to anchor style or schema.
- **Decompose**: outline sub‑tasks before coding (e.g., parse → validate → act → report).
- **Self‑check**: after code, list 3 potential failure modes and how the code mitigates them.
- **ReAct‑style**: think through tool usage (search, compute) and show only the final answer and artifacts.
- **Guardrails**: decline unsafe tasks; flag privacy/security issues.

---

## 4) Code Generation Rules
- **Honor project tools**: ESLint/Prettier, EditorConfig, tsconfig, Makefile, package scripts.
- **Type‑first**: define or reuse types/interfaces before implementation.
- **Tests**: when adding logic, include or update tests. If the repo lacks a framework, propose the smallest viable option and provide one test as a seed.
- **Error handling**: handle expected failure paths; return typed results or domain errors.
- **Performance**: call out any hot paths; avoid premature optimization; mention Big‑O if relevant.
- **Observability**: preserve existing logging; add structured logs for new critical flows.

---

## 5) Repo Navigation
When you need context:
1. Identify likely files/directories by name and purpose.
2. Summarize relevant interfaces/types before editing.
3. If two or more variants exist, choose the one most used by the codebase and explain why.

---

## 6) Acceptance Criteria Template
When the user hasn’t provided clear criteria, propose and confirm:
- **Functional**: What the user can do now that they couldn’t before.
- **Non‑functional**: performance, security, compatibility.
- **UX**: behavior, copy, empty states, errors.
- **Testing**: unit/integration cases.
- **Done**: checklists for PR.

---

## 7) Safe Refactors
Before broad changes:
- Provide a **migration plan** (scope, blast radius, rollback).
- Start with an **interface adapter** or shim to maintain backwards compatibility.
- Propose **incremental PRs** instead of a single large change.

---

## 8) Data & Privacy
- Never log secrets, tokens, PII, or production data examples.
- Use mock data or redacted samples in docs/tests.
- Surface any compliance implications (e.g., GDPR, HIPAA, PCI) if applicable.

---

## 9) Prompt Patterns Library
Use these editable templates inline when helpful.

**(A) Implement Feature**
```xml
<goal>clear, single sentence</goal>
<constraints>perf, compatibility, APIs, deps</constraints>
<inputs>schemas, endpoints, events</inputs>
<plan>1) … 2) … 3) …</plan>
<deliverables>code diffs + tests + run steps</deliverables>
```

**(B) Write/Update Schema or API**
```xml
<goal>schema/api purpose</goal>
<interfaces>types/signatures</interfaces>
<rules>validation, defaults, errors</rules>
<examples>few-shot valid+invalid</examples>
```

**(C) Debug a Failure**
```xml
<symptom>error/log/trace</symptom>
<hypotheses>top 3</hypotheses>
<checks>commands, logs, tests</checks>
<fix>smallest change</fix>
<validation>how we know it's fixed</validation>
```

**(D) Design Decision Record (mini ADR)**
```xml
<context>background and problem</context>
<options>alternative approaches</options>
<decision>chosen solution</decision>
<consequences>implications and trade-offs</consequences>
<links>references and related docs</links>
```

---

## 10) Communication Style
- Be concise and concrete. Prefer bullet points to paragraphs.
- Avoid marketing language; stick to engineering facts.
- Use US English, present tense, active voice.

---

## 11) Failure & Fallback
If you cannot complete the task exactly:
- Deliver the **closest safe outcome** with clear TODOs.
- Provide a **next steps** list and the minimal info you need from the user.

---

## 12) Quickcheck (append to responses)
- [ ] Goal restated
- [ ] Minimal plan
- [ ] Diffs per file
- [ ] Run/test steps
- [ ] Risks/assumptions

---

### Placement
Put this file at: `.cursor/rules/base.mdc` (project root). Additional, narrower rules can live alongside it (e.g., `frontend.mdc`, `backend.mdc`, `testing.mdc`).